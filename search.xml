<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM问题整理</title>
      <link href="/2020/07/12/jvm1/"/>
      <url>/2020/07/12/jvm1/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈?"></a>什么是栈?</h1><p>  栈是先进后出的数据模型，这里指的是运行时栈，主要是进行指令存储和辅助运行。栈是线程私有的，他的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表，操作数栈，动态链接，方法出口等信息。局部变量表又包含基本数据类型，对象引用类型。</p><p>  如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常，方法递归调用产生这种结果。</p><p>  如果JVM可以动态扩展，并且扩展动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建线程的时候没有足够的内存去创建对应的JVM Stack，那么JVM将抛出一个OutOfMemory异常（这是启动过多）</p><h2 id="什么时候会造成栈溢出"><a href="#什么时候会造成栈溢出" class="headerlink" title="什么时候会造成栈溢出?"></a>什么时候会造成栈溢出?</h2><p>  主要时候在进行递归的时候，在进行递归时，未完成不会释放资源，并且递归的次数不容易通过代码控制，如果超出边界就会导致栈溢出，在新建线程的时候没有足够的内存去创建对应的JVM Stack，那么JVM将抛出一个OutOfMemory异常（这是启动过多），这是主存储不够分配。<br>配置参数如下:<br>  -Xss :xxxb</p><h1 id="详解JVM内存模型"><a href="#详解JVM内存模型" class="headerlink" title="详解JVM内存模型"></a>详解JVM内存模型</h1><h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><p><img src="JVM.jpg" alt="JVM运行内存结构"><br>程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。</p><p>Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有。</p><p>Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有。</p><p>Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享。</p><p>方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享</p><h1 id="JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"><a href="#JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。" class="headerlink" title="JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。"></a>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。</h1><h2 id="1）共享内存区划分"><a href="#1）共享内存区划分" class="headerlink" title="1）共享内存区划分"></a>1）共享内存区划分</h2><ul><li>共享内存区 = 持久带 + 堆</li><li>持久带 = 方法区 + 其他</li><li>Java堆 = 老年代 + 新生代</li><li>新生代 = Eden + S0 + S1</li></ul><h2 id="2）一些参数的配置"><a href="#2）一些参数的配置" class="headerlink" title="2）一些参数的配置"></a>2）一些参数的配置</h2><ul><li>默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ，可以通过参数 –XX:NewRatio 配置。</li><li>默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定)</li><li>Survivor区中的对象被复制次数为15(对应虚拟机参数 -XX:+MaxTenuringThreshold)</li></ul><h2 id="3-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？"><a href="#3-为什么要分为Eden和Survivor-为什么要设置两个Survivor区？" class="headerlink" title="3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？"></a>3)为什么要分为Eden和Survivor?为什么要设置两个Survivor区？</h2><ul><li>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,所以需要分为Eden和Survivor。</li><li>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</li><li>设置两个Survivor区最大的好处就是解决了碎片化，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）</li></ul><h1 id="JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"><a href="#JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代" class="headerlink" title="JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代"></a>JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代</h1><ul><li>Java堆 = 老年代 + 新生代</li><li>新生代 = Eden + S0 + S1</li><li>当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，则会转移到 Survivor区。</li><li>大对象（需要大量连续内存空间的Java对象，如那种很长的字符串）直接进入老年态；</li><li>如果对象在Eden出生，并经过第一次Minor GC后仍然存活，并且被Survivor容纳的话，年龄设为1，每熬过一次Minor GC，年龄+1，若年龄超过一定限制（15），则被晋升到老年态。即长期存活的对象进入老年态。</li><li>老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代。</li><li>Major GC 发生在老年代的GC，清理老年区，经常会伴随至少一次Minor GC，比Minor GC慢10倍以上。</li></ul><h1 id="你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"><a href="#你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。" class="headerlink" title="你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。"></a>你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。</h1><h2 id="1）几种垃圾收集器："><a href="#1）几种垃圾收集器：" class="headerlink" title="1）几种垃圾收集器："></a>1）几种垃圾收集器：</h2><ul><li>Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。</li><li>ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。</li><li>Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。</li><li>Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。</li><li>Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。</li><li>CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。</li><li>G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。</li></ul><h2 id="2）CMS收集器和G1收集器的区别："><a href="#2）CMS收集器和G1收集器的区别：" class="headerlink" title="2）CMS收集器和G1收集器的区别："></a>2）CMS收集器和G1收集器的区别：</h2><ul><li>CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；</li><li>G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；</li><li>CMS收集器以最小的停顿时间为目标的收集器；</li><li>G1收集器可预测垃圾回收的停顿时间</li><li>CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片</li><li>G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。</li></ul><h1 id="JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"><a href="#JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。" class="headerlink" title="JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。"></a>JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存。</h1><h2 id="1）Java内存模型图："><a href="#1）Java内存模型图：" class="headerlink" title="1）Java内存模型图："></a>1）Java内存模型图：</h2><p><img src="JVM2.jpg" alt="JAVA内存模型图"><br>  Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><h2 id="2）指令重排序。"><a href="#2）指令重排序。" class="headerlink" title="2）指令重排序。"></a>2）指令重排序。</h2><p>在这里，先看一段代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PossibleReordering</span> <span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    Thread one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            x <span class="token operator">=</span> b<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread other <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            y <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    one<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>other<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    one<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>other<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“<span class="token punctuation">(</span>” <span class="token operator">+</span> x <span class="token operator">+</span> “<span class="token punctuation">,</span>” <span class="token operator">+</span> y <span class="token operator">+</span> “<span class="token punctuation">)</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果可能为(1,0)、(0,1)或(1,1)，也可能是(0,0)。因为，在实际运行时，代码指令可能并不是严格按照代码语句顺序执行的。大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。而这就是指令重排。</p><h2 id="3）内存屏障"><a href="#3）内存屏障" class="headerlink" title="3）内存屏障"></a>3）内存屏障</h2><p>内存屏障，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。</p><ul><li>LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li><li>StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li><li>LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li><li>StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。</li></ul><h2 id="4）happen-before原则"><a href="#4）happen-before原则" class="headerlink" title="4）happen-before原则"></a>4）happen-before原则</h2><ul><li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。 锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</li><li>volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</li><li>happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</li><li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li><li>线程中断的happen-before原则 ：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li><li>线程终结的happen-before原则： 线程中的所有操作都happen-before线程的终止检测。</li><li>对象创建的happen-before原则： 一个对象的初始化完成先于他的finalize方法调用。</li></ul><h1 id="简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"><a href="#简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。" class="headerlink" title="简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。"></a>简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。</h1><h2 id="1-什么是类加载器？"><a href="#1-什么是类加载器？" class="headerlink" title="1) 什么是类加载器？"></a>1) 什么是类加载器？</h2><p><strong>类加载器</strong> 就是根据指定全限定名称将class文件加载到JVM内存，转为Class对象。</p><ul><li>启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在<JAVA_HOME>\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</li><li>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如：<br> 扩展类加载器（Extension ClassLoader）：负责加载<JAVA_HOME>\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。<br> 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li></ul><h2 id="2）双亲委派模型"><a href="#2）双亲委派模型" class="headerlink" title="2）双亲委派模型"></a>2）双亲委派模型</h2><p><strong>双亲委派模型工作过程是：</strong><br>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。<br>双亲委派模型图：<br><img src="JVM3.jpg" alt="双亲委派模型图"></p><h2 id="3）为什么需要双亲委派模型？"><a href="#3）为什么需要双亲委派模型？" class="headerlink" title="3）为什么需要双亲委派模型？"></a>3）为什么需要双亲委派模型？</h2><p>在这里，先想一下，如果没有双亲委派，那么用户是不是可以自己定义一个java.lang.Object的同名类，java.lang.String的同名类，并把它放到ClassPath中,那么类之间的比较结果及类的唯一性将无法保证，因此，为什么需要双亲委派模型？防止内存中出现多份同样的字节码</p><h2 id="4）怎么打破双亲委派模型？"><a href="#4）怎么打破双亲委派模型？" class="headerlink" title="4）怎么打破双亲委派模型？"></a>4）怎么打破双亲委派模型？</h2><p>打破双亲委派机制则不仅要继承ClassLoader类，还要重写loadClass和findClass方法。</p><h1 id="说说你知道的几种主要的JVM参数"><a href="#说说你知道的几种主要的JVM参数" class="headerlink" title="说说你知道的几种主要的JVM参数"></a>说说你知道的几种主要的JVM参数</h1><h2 id="1）堆栈配置相关"><a href="#1）堆栈配置相关" class="headerlink" title="1）堆栈配置相关"></a>1）堆栈配置相关</h2><pre><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:MaxPermSize=16m -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0</code></pre><ul><li><p>Xmx3550m： 最大堆大小为3550m。</p></li><li><p>Xms3550m： 设置初始堆大小为3550m。</p></li><li><p>Xmn2g： 设置年轻代大小为2g。</p></li><li><p>Xss128k： 每个线程的堆栈大小为128k。</p></li><li><p>XX:MaxPermSize： 设置持久代大小为16m</p></li><li><p>XX:NewRatio=4: 设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。</p></li><li><p>XX:SurvivorRatio=4： 设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6</p></li><li><p>XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。</p></li></ul><h2 id="2）垃圾收集器相关"><a href="#2）垃圾收集器相关" class="headerlink" title="2）垃圾收集器相关"></a>2）垃圾收集器相关</h2><pre><code>-XX:+UseParallelGC-XX:ParallelGCThreads=20-XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5-XX:+UseCMSCompactAtFullCollection：</code></pre><ul><li><p>XX:+UseParallelGC： 选择垃圾收集器为并行收集器。</p></li><li><p>XX:ParallelGCThreads=20： 配置并行收集器的线程数</p></li><li><p>XX:+UseConcMarkSweepGC： 设置年老代为并发收集。</p></li><li><p>XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p></li><li><p>XX:+UseCMSCompactAtFullCollection： 打开对年老代的压缩。可能会影响性能，但是可以消除碎片</p></li></ul><h2 id="3）辅助信息相关"><a href="#3）辅助信息相关" class="headerlink" title="3）辅助信息相关"></a>3）辅助信息相关</h2><pre><code>-XX:+PrintGC-XX:+PrintGCDetails</code></pre><p>-XX:+PrintGC 输出形式:</p><p>[GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</p><p>-XX:+PrintGCDetails 输出形式:</p><p>[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs</p><h1 id="怎么打出线程栈信息"><a href="#怎么打出线程栈信息" class="headerlink" title="怎么打出线程栈信息"></a>怎么打出线程栈信息</h1><ul><li>输入jps，获得进程号。</li><li>top -Hp pid 获取本进程中所有线程的CPU耗时性能</li><li>jstack pid命令查看当前java进程的堆栈状态</li><li>或者 jstack -l &gt; /tmp/output.txt 把堆栈信息打到一个txt文件。</li><li>可以使用fastthread 堆栈定位，fastthread.io/</li></ul><h1 id="强引用、软引用、弱引用、虚引用的区别？"><a href="#强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别？"></a>强引用、软引用、弱引用、虚引用的区别？</h1><h2 id="1）强引用"><a href="#1）强引用" class="headerlink" title="1）强引用"></a>1）强引用</h2><p>我们平时new了一个对象就是强引用，例如 Object obj = new Object();即使在内存不足的情况下，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。</p><h2 id="2）软引用"><a href="#2）软引用" class="headerlink" title="2）软引用"></a>2）软引用</h2><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。<br><code>SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str);     // 软引用</code><br>用处： 软引用在实际中有重要的应用，例如浏览器的后退按钮。按后退时，这个后退时显示的网页内容是重新进行请求还是从缓存中取出呢？这就要看具体的实现策略了。</p><p>（1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建</p><p>（2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出<br>如下代码：</p><pre class=" language-java"><code class="language-java">Browser prev <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Browser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 获取页面进行浏览</span>SoftReference sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 浏览完毕后置为软引用        </span><span class="token keyword">if</span><span class="token punctuation">(</span>sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>     rev <span class="token operator">=</span> <span class="token punctuation">(</span>Browser<span class="token punctuation">)</span> sr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 还没有被回收器回收，直接获取</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    prev <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Browser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// 由于内存吃紧，所以对软引用的对象回收了</span>    sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 重新构建</span><span class="token punctuation">}</span></code></pre><h2 id="3）弱引用"><a href="#3）弱引用" class="headerlink" title="3）弱引用"></a>3）弱引用</h2><p>具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p><pre class=" language-java"><code class="language-java">String str<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    WeakReference<span class="token operator">&lt;</span>String<span class="token operator">></span> abcWeakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>str<span class="token operator">=</span>null<span class="token punctuation">;</span>等价于str <span class="token operator">=</span> null<span class="token punctuation">;</span>System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="4）虚引用"><a href="#4）虚引用" class="headerlink" title="4）虚引用"></a>4）虚引用</h2><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。<br><a href="https://blog.csdn.net/qq_41701956/article/details/100074023" target="_blank" rel="noopener">原文博客地址:https://blog.csdn.net/qq_41701956/article/details/100074023</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Markdown </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序算法</title>
      <link href="/2020/07/11/suanfa/"/>
      <url>/2020/07/11/suanfa/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。</p><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p> 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：<br> <img src="dxdui.png" alt="大顶堆和小顶堆"><br> 同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子<br> <strong>大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong><br> <strong>小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> </p><h1 id="堆排序基本思想及步骤"><a href="#堆排序基本思想及步骤" class="headerlink" title="堆排序基本思想及步骤"></a>堆排序基本思想及步骤</h1><p> 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了<br> <strong>步骤一 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</strong><br> 1.假设给定无序序列结构如下<br> <img src="wuxuxulie.png" alt="无序序列"><br> 2.此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的6结点），从左至右，从下至上进行调整。<br> <img src="paixu1.png" alt="从最后一个非叶子节点开始调整"><br> 3.找到第二个非叶节点4，由于[4,9,8]中9元素最大，4和9交换。<br> <img src="paixu2.png" alt="调整倒数第二个非叶子节点"><br> 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。<br> <img src="paixu3.png" alt="构造好的大顶堆"><br> <strong>步骤二 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong><br> a.将堆顶元素9和末尾元素4进行交换<br> <img src="change1.png" alt="大顶堆最大元素和末尾元素交换位置"><br> b.重新调整结构，使其继续满足堆定义<br> <img src="change2.png" alt="继续调换n-1最大元素和末尾元素"><br> c.再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.<br> <img src="change3.png" alt="继续调换n-1最大元素和末尾元素"><br> 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序<br> <img src="change4.png" alt="最终构成一个升序序列"><br> 再简单总结下堆排序的基本思路：<br>　　<strong>a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong><br>　　<strong>b.将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端;</strong><br>　　<strong>c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> sortdemo<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Created by chengxiao on 2016/12/17. * 堆排序demo */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1.构建大顶堆</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//从第一个非叶子结点从下至上，从右至左调整结构</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//2.调整堆结构+交换堆顶元素与末尾元素</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>arr<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将堆顶元素与末尾元素进行交换</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//重新对堆进行调整</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）     * @param arr     * @param i     * @param length     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//先取出当前元素i</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>k<span class="token operator">=</span>k<span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//从i结点的左子结点开始，也就是2i+1处开始</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>length <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果左子结点小于右子结点，k指向右子结点</span>                k<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span>temp<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将temp值放到最终的位置</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 交换元素     * @param arr     * @param a     * @param b     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>arr<span class="token punctuation">,</span><span class="token keyword">int</span> a <span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span>arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果<br>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)…1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。</p><p>本文参考<a href="http://www.cnblogs.com/chengxiao/" target="_blank" rel="noopener">原作者博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Markdown </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/09/hello-world/"/>
      <url>/2020/06/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
